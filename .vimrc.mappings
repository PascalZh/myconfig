"
" functions and commands{{{
func! s:WipeOutBuffer()
  " when editing vimrc files
  if bufnr('vimrc') != -1
    tabclose
    wa
    silent execute "bw " . bufnr('vimrc.mappings')
          \." ".bufnr('vimrc')
          \." ".bufnr('vimrc.appearance')
          \." ".bufnr('vimrc.bundles')
    nnoremap J <C-W>j
    nnoremap K <C-W>k
    nnoremap H <C-W>h
    nnoremap L <C-W>l
  elseif winnr('$')==1
    quit
  else
    bw
  endif
endfunc
func! ManageMyVimrcFiles()
  tabedit $MYVIMRC
  vsplit ~/.vimrc.mappings
  wincmd h
  split ~/.vimrc.bundles
  wincmd l
  split ~/.vimrc.appearance
  1wincmd w
  nnoremap J <C-W>j:resize 999<CR>
  nnoremap K <C-W>k:resize 999<CR>
  nnoremap H <C-W>h:resize 999<CR>
  nnoremap L <C-W>l:resize 999<CR>
endfunc
" Allow to trigger background
    function! ToggleBG()
        let s:tbg = &background
        " Inversion
        if s:tbg == "dark"
            set background=light
        else
            set background=dark
        endif
    endfunction
" QuickfixToggle(){{{2
let g:quickfix_is_open=0
func! QuickfixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
    else
        botright copen
        let g:quickfix_is_open = 1
    endif
endfunc
"}}}
    " Shell command {{{2
    function! s:RunShellCommand(cmdline)
        botright new

        setlocal buftype=nofile
        setlocal bufhidden=delete
        setlocal nobuflisted
        setlocal noswapfile
        setlocal nowrap
        setlocal filetype=shell
        setlocal syntax=shell

        call setline(1, a:cmdline)
        call setline(2, substitute(a:cmdline, '.', '=', 'g'))
        execute 'silent $read !' . escape(a:cmdline, '%#')
        normal! gg
        put! ='Press q to quit.'
        setlocal nomodifiable
        nmap <buffer> q :bd<cr>:wincmd p<cr>
        1
    endfunction

    command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)
    " e.g. Grep current file for <search_term>: Shell grep -Hn <search_term> %
    " }}}
" }}}
    " basic {{{1
    nnoremap <tab> :bnext<cr>
    nnoremap <S-tab> :bprevious<CR>
    inoremap jk <ESC>

" leader and , {{{1
let mapleader=";"
if has('perl')
nnoremap <leader>a :Ack!<Space>
endif
nnoremap <leader>ev :call ManageMyVimrcFiles()<cr>
nnoremap <leader>bg :call ToggleBG()<CR>
" normal: <leader>c+...:NERDCommenter
nnoremap <leader>sv :wa<CR>:so $MYVIMRC<CR>
nnoremap <leader>sw :FSHere<cr>
nnoremap <leader>sh :Shell<Space>
nnoremap <leader><space> :nohlsearch<cr>
nnoremap <leader>u :GundoToggle<cr>
" wipeout the buffer, don't apply it in other special window.
nnoremap <leader>q :call <SID>WipeOutBuffer()<cr>
nnoremap <leader>f za
nnoremap ,e :call NERDTreeToggleAndMap_b_()<cr>
nnoremap ,q :call QuickfixToggle()<cr>
if LINUX()
nnoremap ,t :TagbarToggle<cr>
endif
nnoremap ,c :ColorExplorerToggle<cr>
 
" easymotion {{{1
" do not use nnoremap and others like this.
nmap <space>s <Plug>(easymotion-s)
vmap <space>s <Plug>(easymotion-s)
nmap <space>w <Plug>(easymotion-bd-w)
vmap <space>w <Plug>(easymotion-bd-w)
nmap <space>g <Plug>(easymotion-overwin-f)
vmap <space>g <Plug>(easymotion-overwin-f)
nmap <space>j <Plug>(easymotion-jumptoanywhere)
vmap <space>j <Plug>(easymotion-jumptoanywhere)
    " {{{1解决编辑中文文档的输入法切换（暂未解决）
    "inoremap jk <ESC><S>
    "nnoremap i i<S>
    "nnoremap I I<S>
    "nnoremap a a<S>
    "nnoremap A A<S>
    "nnoremap C C<S>
    " c的问题还没有解决办法，不过也没什么必要
    "nnoremap o o<S>
    "nnoremap O O<S>
    "nnoremap s s<S>
    "nnoremap S S<S>

    " window move and manipulation{{{1
nnoremap <c-k> :resize+3<cr>
nnoremap <c-j> :resize-3<cr>
nnoremap <c-h> :vertical resize-3<cr>
nnoremap <c-l> :vertical resize+3<cr>
nnoremap H <C-w>h
nnoremap L <C-w>l
nnoremap J <C-w>j
nnoremap K <C-w>k

" other {{{1
    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$

" grep (TODO) {{{1

" grep the words in the path where the file is located.
"nnoremap <leader>g g@
"vnoremap <leader>g :<c-u>call MyGrepFunc(visualmode())<cr>
" toggle quickfix window

"set opfunc=MyGrepFunc
"func! MyGrepFunc(type)
"    let saved_unnamed_register = @@

"    if a:type ==# 'v' || a:type ==# 'V' || a:type ==# ''
"        normal! `<v`>y
"    elseif a:type ==# 'char'
"        normal! `[v`]sy
"    else
"        return
"    endif

" version1: find in the files that have the same extension
"    silent! execute "vimgrep /" . expand(@@) . "/gj *." . expand("%:e")

"    copen
"execute "normal! \<c-w>p"

"    let @@ = saved_unnamed_register
"endfunc
" }}} 
