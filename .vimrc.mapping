command! Q q!
command! Qa qa!

" leader and , {{{1
let mapleader=";"

nnoremap <leader><space> :nohlsearch<cr>
nnoremap <leader>bg :call ToggleBG()<CR>
nnoremap <leader>ev :call ManageMyVimrcFiles()<cr>
nnoremap <leader>f za
vnoremap <leader>g :<c-u>call MyGrepFunc(visualmode())<cr>
nmap <leader>g g@
"<leader>hp              Preview the hunk under the cursor.
"<leader>hs              Stage the hunk under the cursor.
"<leader>hu              Undo the hunk under the cursor.
nnoremap <leader>l :set list!<CR>
nnoremap <leader>q :call PascalQuit()<cr>
nnoremap <leader>sh :terminal<cr>
"nnoremap <leader>sv :wa<CR>:so $MYVIMRC<CR>
nnoremap <leader>sw :FSHere<cr>
nnoremap <leader>t :Tabularize /
nnoremap <leader>u :Utl<cr>
"nmap <leader>uhs :let g:utl_cfg_hdl_scm_http=g:utl_cfg_hdl_scm_http_system<cr>
"nmap <leader>uhw :let g:utl_cfg_hdl_scm_http=g:utl_cfg_hdl_scm_http__wget<cr>
nnoremap <leader>w :wa<cr>

nnoremap ,u :GundoToggle<cr>
nnoremap ,e :call NERDTreeToggleAndMap_b_()<cr>
nnoremap ,q :call QuickfixToggle("qf")<cr>
nnoremap ,l :call QuickfixToggle("ll")<cr>
"nnoremap ,t :TagbarToggle<cr>
nnoremap ,c :ColorExplorerToggle<cr>
nnoremap ,r :RainbowParenthesesToggleAll<CR>

" }}}

" basic {{{1
nnoremap Y y$
nnoremap <Tab> :bnext<cr>
nnoremap <S-Tab> :bprevious<CR>
" jk kj in insert mode are mapped to <esc> by vim-easyescape
inoremap ;k ;<ESC>

vnoremap < <gv
vnoremap > >gv
nnoremap H <C-w>h
nnoremap L <C-w>l
nnoremap J <C-w>j
nnoremap K <C-w>k
" }}}

" space mappings {{{1
nmap <space>ef <Plug>(easymotion-overwin-f)
xmap <space>ef <Plug>(easymotion-overwin-f)
nmap <space>ej <Plug>(easymotion-jumptoanywhere)
xmap <space>ej <Plug>(easymotion-jumptoanywhere)
nmap <space>ew <Plug>(easymotion-overwin-w)
xmap <space>ew <Plug>(easymotion-overwin-w)
nmap <space>ee <Plug>(easymotion-overwin-e)
xmap <space>ee <Plug>(easymotion-overwin-e)
nmap <space>c <Plug>NERDCommenterToggle
xmap <space>c <Plug>NERDCommenterToggle
nnoremap <space>mf :wa<cr>:!make flash<cr>
nnoremap <space>mm :!make monitor<cr>

nnoremap <space>f za
au BufEnter *.rkt,*.rktl nnoremap <buffer> <space>r :!racket -t %<cr>
" }}}

" grep or ack {{{1

" grep the words in the path where the file is located.

set opfunc=MyGrepFunc
func! MyGrepFunc(type)
  let s:store_temp_register=@z
  if a:type ==# 'v' || a:type ==# 'V' || a:type ==# ''
    normal! `<v`>"zy
  elseif a:type ==# 'char'
    normal! `[v`]"zy
  else
    return
  endif

  if LINUX()
    execute "Ack! " . expand(@z)
  elseif WINDOWS()
    silent! execute "vimgrep /" . expand(@z) . "/gj **/*.*"
  endif

  botright copen
  let @z=s:store_temp_register
endfunc
" }}}
" PascalQuit() {{{
func! PascalQuit()
  " when editing vimrc files
  if bufnr('.vimrc')                == winbufnr(0) ||
        \bufnr('.vimrc.mapping')    == winbufnr(0) ||
        \bufnr('.vimrc.appearance') == winbufnr(0) ||
        \bufnr('.vimrc.bundle')     == winbufnr(0) ||
        \bufnr('.vimrc.language')   == winbufnr(0)

    if bufnr('.vimrc.mapping')
      silent! bw .vimrc.mapping
    endif
    if bufnr('.vimrc')
      silent! bw .vimrc
    endif
    if bufnr('.vimrc.appearance')
      silent! bw .vimrc.appearance
    endif
    if bufnr('.vimrc.bundle')
      silent! bw .vimrc.bundle
    endif
    if bufnr('.vimrc.language')
      silent! bw .vimrc.language
    endif
  else
    quit
  endif
endfunc
" }}}
" ManageMyVimrcFiles() {{{
func! ManageMyVimrcFiles()
  tabedit ~/.vimrc
  vsplit ~/.vimrc.mapping
  wincmd h
  split ~/.vimrc.bundle
  wincmd l
  split ~/.vimrc.appearance
  split ~/.vimrc.language
  1wincmd w
endfunc
" }}}
" Toggle background {{{
function! ToggleBG()
  let s:tbg = &background
  " Inversion
  if s:tbg == "dark"
    set background=light
  else
    set background=dark
  endif
endfunction
" }}}
" QuickfixToggle() {{{
au FileType qf map <buffer> q <C-W>q:let g:quickfix_is_open=0<cr>|
      \  map <buffer> t <C-W><CR><C-W>T|
      \  map <buffer> gt <C-W><CR><C-W>TgT<C-W>j|
      \  map <buffer> o <CR>|
      \  map <buffer> go <CR><C-W>j|
      \  map <buffer> s <C-W><CR><C-W>K|
      \  map <buffer> gs <C-W><CR><C-W>K<C-W>b|
      \  map <buffer> v <C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t|
      \  map <buffer> gv <C-W><CR><C-W>H<C-W>b<C-W>J|
      \let g:quickfix_is_open=1

let g:quickfix_is_open=0
func! QuickfixToggle(flag)
  if g:quickfix_is_open
    if a:flag == "qf"
      cclose
    elseif a:flag == "ll"
      lclose
    endif
    wincmd p
    let g:quickfix_is_open = 0
  else
    if a:flag == "qf"
      botright copen
    elseif a:flag == "ll"
      botright lopen
    endif
  endif
endfunc
"}}}

" Shell command(deleted) {{{
"function! s:RunShellCommand(cmdline)
"botright new

"setlocal buftype=nofile
"setlocal bufhidden=delete
"setlocal nobuflisted
"setlocal noswapfile
"setlocal nowrap
"setlocal filetype=shell
"setlocal syntax=shell

"call setline(1, a:cmdline)
"call setline(2, substitute(a:cmdline, '.', '=', 'g'))
"execute 'silent $read !' . escape(a:cmdline, '%#')
"normal! gg
"put! ='Press q to quit.'
"setlocal nomodifiable
"nmap <buffer> q :bd<cr>:wincmd p<cr>
"1
"endfunction

"command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)
" e.g. Grep current file for <search_term>: Shell grep -Hn <search_term> %
" }}}
" {{{1解决编辑中文文档的输入法切换（暂未解决）
"inoremap jk <ESC><S>
"nnoremap i i<S>
"nnoremap I I<S>
"nnoremap a a<S>
"nnoremap A A<S>
"nnoremap C C<S>
" c的问题还没有解决办法，不过也没什么必要
"nnoremap o o<S>
"nnoremap O O<S>
"nnoremap s s<S>
"nnoremap S S<S>
" }}}

" M (man): get helped {{{

nnoremap M K
vnoremap M K
au BufEnter *.rkt,*.rktl nnoremap <buffer> M :silent !raco docs <cword><cr>:redraw!<cr>
au BufEnter *.rkt,*.rktl vnoremap <buffer> M :call <SID>Racket_visual_doc()<cr>

" For the visual mode M mapping, it's slightly more convoluted to get the 
" selected text:
function! s:Racket_visual_doc()
  try
    let l:old_a = @a
    normal! gv"ay
    call system("raco docs '". @a . "'")
    redraw!
    return @a
  finally
    let @a = l:old_a
  endtry
endfunction
" }}}

" for latex {{{
augroup  LaTeX
  au!
  "d means dollar.
  au FileType tex imap ;d $
augroup END
" }}}
