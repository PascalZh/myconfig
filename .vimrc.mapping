" leader and , {{{1
let mapleader=";"
nnoremap <leader>ev :call ManageMyVimrcFiles()<cr>
nnoremap <leader>bg :call ToggleBG()<CR>
" normal: <leader>c+...:NERDCommenter
nmap <leader>g g@
vnoremap <leader>g :<c-u>call MyGrepFunc(visualmode())<cr>
nnoremap <leader>l :set list!<CR>
"nnoremap <leader>sv :wa<CR>:so $MYVIMRC<CR>
nnoremap <leader>sw :FSHere<cr>
nnoremap <leader>sh :terminal<cr>
nnoremap <leader>t :Tabularize /
nnoremap <leader><space> :nohlsearch<cr>
" wipeout the buffer, don't apply it in other special window.
nnoremap <leader>q :call PascalQuit()<cr>
nnoremap <leader>f za

nnoremap <leader>n :ALENextWrap<cr>
nnoremap <leader>p :ALEPreviousWrap<cr>
nnoremap <leader>w :wa<cr>

nnoremap <leader>u :Utl<cr>
"nmap <Leader>uhs :let g:utl_cfg_hdl_scm_http=g:utl_cfg_hdl_scm_http_system<cr>
"nmap <Leader>uhw :let g:utl_cfg_hdl_scm_http=g:utl_cfg_hdl_scm_http__wget<cr>

nnoremap ,u :GundoToggle<cr>
nnoremap ,e :call NERDTreeToggleAndMap_b_()<cr>
nnoremap ,q :call QuickfixToggle()<cr>
if LINUX()
  nnoremap ,t :TagbarToggle<cr>
endif
nnoremap ,c :ColorExplorerToggle<cr>
nnoremap ,r :RainbowParenthesesToggleAll<CR>

" basic {{{1
nnoremap <tab> :bnext<cr>
nnoremap <S-tab> :bprevious<CR>
"inoremap kj <ESC>
inoremap ;a <ESC>
vnoremap < <gv
vnoremap > >gv
map <F4> :BadApple restoregui<CR>
map <F7> :BadApple<CR>
" }}}
" easymotion(and space mappings) {{{1
" do not use nnoremap and others like this.
nnoremap <space><space> :
"nmap <space>f <Plug>(easymotion-s)
"xmap <space>f <Plug>(easymotion-s)

nmap <space>w <Plug>(easymotion-bd-w)
xmap <space>w <Plug>(easymotion-bd-w)


nmap <space>f <Plug>(easymotion-overwin-f)
xmap <space>f <Plug>(easymotion-overwin-f)

nmap <space>j <Plug>(easymotion-jumptoanywhere)
xmap <space>j <Plug>(easymotion-jumptoanywhere)

nmap <space>mf :wa<cr>:!make flash<cr>
nmap <space>mm :!make monitor<cr>



" {{{1解决编辑中文文档的输入法切换（暂未解决）
"inoremap jk <ESC><S>
"nnoremap i i<S>
"nnoremap I I<S>
"nnoremap a a<S>
"nnoremap A A<S>
"nnoremap C C<S>
" c的问题还没有解决办法，不过也没什么必要
"nnoremap o o<S>
"nnoremap O O<S>
"nnoremap s s<S>
"nnoremap S S<S>

" window move and manipulation{{{1
nnoremap <C-k> :resize+3<cr>
nnoremap <C-j> :resize-3<cr>
nnoremap <C-h> :vertical resize-3<cr>
nnoremap <C-l> :vertical resize+3<cr>
nnoremap H <C-w>h
nnoremap L <C-w>l
nnoremap J <C-w>j
nnoremap K <C-w>k

" other {{{1
" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$

" grep or ack {{{1

" grep the words in the path where the file is located.

set opfunc=MyGrepFunc
func! MyGrepFunc(type)
  let s:store_temp_register=@z
  if a:type ==# 'v' || a:type ==# 'V' || a:type ==# ''
    normal! `<v`>"zy
  elseif a:type ==# 'char'
    normal! `[v`]"zy
  else
    return
  endif

  if LINUX()
    execute "Ack! " . expand(@z)
  elseif WINDOWS()
    silent! execute "vimgrep /" . expand(@z) . "/gj **/*.*"
  endif

  botright copen
  let @z=s:store_temp_register
endfunc
" }}}
" functions and commands{{{1
command! Q q!
command! Qa qa!
" PascalQuit(){{{2
func! PascalQuit()
  " when editing vimrc files
  if bufnr('.vimrc') != -1 || bufnr('.vimrc.mapping') != -1 ||
        \bufnr('.vimrc.appearance') != -1 || bufnr('.vimrc.bundle') != -1 ||
        \bufnr('.vimrc.syntax') != -1
    if bufnr('.vimrc.mapping') != -1
      silent execute "bw " . bufnr('.vimrc.mapping')
    endif
    if bufnr('.vimrc') != -1
      silent execute "bw " . bufnr('.vimrc')
    endif
    if bufnr('.vimrc.appearance') != -1
      silent execute "bw " . bufnr('.vimrc.appearance')
    endif
    if bufnr('.vimrc.bundle') != -1
      silent execute "bw " . bufnr('.vimrc.bundle')
    endif
    if bufnr('.vimrc.syntax') != -1
      silent execute "bw " . bufnr('.vimrc.syntax')
    endif

  else
    q
  endif
endfunc
" ManageMyVimrcFiles() {{{2
func! ManageMyVimrcFiles()
  tabedit ~/.vimrc
  vsplit ~/.vimrc.mapping
  wincmd h
  split ~/.vimrc.bundle
  wincmd l
  split ~/.vimrc.appearance
  split ~/.vimrc.syntax
  1wincmd w
  "nnoremap J <C-W>j:resize 999<CR>
  "nnoremap K <C-W>k:resize 999<CR>
  "nnoremap H <C-W>h:resize 999<CR>
  "nnoremap L <C-W>l:resize 999<CR>
endfunc
" Allow to trigger background {{{2
function! ToggleBG()
  let s:tbg = &background
  " Inversion
  if s:tbg == "dark"
    set background=light
  else
    set background=dark
  endif
endfunction
" QuickfixToggle(){{{2
au FileType qf map <buffer> q <C-W>q:let g:quickfix_is_open=0<cr>|
      \  map <buffer> t <C-W><CR><C-W>T|
      \  map <buffer> gt <C-W><CR><C-W>TgT<C-W>j|
      \  map <buffer> o <CR>|
      \  map <buffer> go <CR><C-W>j|
      \  map <buffer> s <C-W><CR><C-W>K|
      \  map <buffer> gs <C-W><CR><C-W>K<C-W>b|
      \  map <buffer> v <C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t|
      \  map <buffer> gv <C-W><CR><C-W>H<C-W>b<C-W>J|
      \let g:quickfix_is_open=1

let g:quickfix_is_open=0
func! QuickfixToggle()
  if g:quickfix_is_open
    cclose
    let g:quickfix_is_open = 0
  else
    botright copen
    "map <buffer> q <C-W>q
    "map <buffer> t <C-W><CR><C-W>T
    "map <buffer> gt <C-W><CR><C-W>TgT<C-W>j
    "map <buffer> o <CR>
    "map <buffer> go <CR><C-W>j
    "map <buffer> s <C-W><CR><C-W>K
    "map <buffer> gs <C-W><CR><C-W>K<C-W>b
    "map <buffer> v <C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t
    "map <buffer> gv <C-W><CR><C-W>H<C-W>b<C-W>J
    "let g:quickfix_is_open = 1
  endif
endfunc
"}}}
" Shell command(deleted) {{{2
"function! s:RunShellCommand(cmdline)
"botright new

"setlocal buftype=nofile
"setlocal bufhidden=delete
"setlocal nobuflisted
"setlocal noswapfile
"setlocal nowrap
"setlocal filetype=shell
"setlocal syntax=shell

"call setline(1, a:cmdline)
"call setline(2, substitute(a:cmdline, '.', '=', 'g'))
"execute 'silent $read !' . escape(a:cmdline, '%#')
"normal! gg
"put! ='Press q to quit.'
"setlocal nomodifiable
"nmap <buffer> q :bd<cr>:wincmd p<cr>
"1
"endfunction

"command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)
" e.g. Grep current file for <search_term>: Shell grep -Hn <search_term> %
" }}}
" }}}
" for latex {{{1
augroup  LaTeX
  au!
  "d means dollar.
  au FileType latex imap ;d
augroup END
" M and help {{{1

nnoremap M K
vnoremap M K
au BufEnter *.rkt,*.rktl nnoremap <buffer> M :silent !raco docs <cword><cr>:redraw!<cr>
au BufEnter *.rkt,*.rktl vnoremap <buffer> M :call <SID>Racket_visual_doc()<cr>
au BufEnter *.rkt,*.rktl nnoremap <buffer> <space>r :!racket -t %<cr>

" For the visual mode M mapping, it's slightly more convoluted to get the 
" selected text:
function! s:Racket_visual_doc()
  try
    let l:old_a = @a
    normal! gv"ay
    call system("raco docs '". @a . "'")
    redraw!
    return @a
  finally
    let @a = l:old_a
  endtry
endfunction
