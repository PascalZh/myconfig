command! Q q!
command! Qa qa!
command! Zenmode execute "Goyo | Limelight"

" leader and , {{{1
let mapleader=";"

nmap <leader><space> :nohlsearch<cr>
nmap <leader>bg :call ToggleBG()<CR>
nmap <leader>ev :call ManageMyVimrcFiles()<cr>
vmap <leader>g :<c-u>call MyGrepFunc(visualmode())<cr>
nmap <leader>g g@

"imap <leader>im <C-O>:call blitz#input_method_open()<CR>|imap <leader>ic <C-O>:call blitz#input_method_close()<CR>
nmap <expr> <leader>r ":split term://ghci ".expand('%')."\n"
"nmap <leader>sv :wa<CR>:so $MYVIMRC<CR>
nmap <leader>sw :FSHere<cr>

nmap <silent> <leader>wh :call animate#window_delta_width(-10)<CR>
nmap <silent> <leader>wl :call animate#window_delta_width(10)<CR>
nmap <silent> <leader>wj :call animate#window_delta_height(-5)<CR>
nmap <silent> <leader>wk :call animate#window_delta_height(5)<CR>

nmap <leader>t :Tabularize /
vmap <leader>t :Tabularize /
nmap <leader>u :Utl<cr>
"nmap <leader>uhs :let g:utl_cfg_hdl_scm_http=g:utl_cfg_hdl_scm_http_system<cr>
"nmap <leader>uhw :let g:utl_cfg_hdl_scm_http=g:utl_cfg_hdl_scm_http__wget<cr>

nmap ,c :ColorExplorerToggle<cr>
nmap <silent> ,e :call NERDTreeToggleAndMap_b_()<cr>
nmap ,m :GundoToggle<cr>
nmap <silent> ,l :call QuickfixToggle("ll")<cr>
nmap <silent> ,q :call QuickfixToggle("qf")<cr>
nmap ,s :Startify<cr>

" }}}

" My own plugin

"if system("pgrep -f Practice/Shell/record_keyboard.py") == ""
"  call jobstart(["python3", expand("~/Practice/Shell/record_keyboard.py")
"        \, expand("~/Practice/Shell/kb_record.db")]
"        \, {'detach':1})
"endif
"au VimLeave * call system("pgrep -f Practice/Shell/record_keyboard.py | xargs -r kill")

nmap <F1> :ZOmniwindowToggle<enter>
imap <F1> <esc>:ZOmniwindowToggle<enter>
tmap <F1> <C-\><C-n>:ZOmniwindowToggle<enter>

" In order to use pear-tree, don't use noremap
imap <expr> j easy_jk#map_j()
imap <expr> k easy_jk#map_k()
cnoremap <expr> j easy_jk#map_j()
cnoremap <expr> k easy_jk#map_k()

vmap X y/<C-R>"<CR>
nnoremap <space> 2gj

" Basic

nnoremap Y y$

nnoremap <silent> <Tab> :bn<cr>
nnoremap <silent> <S-Tab> :bN<CR>
" <C-i> is bind to <Tab>, so remapping <Tab> will cause <C-i> remapping the
" same as <Tab>, so we need to fix it remapping it to itself:
nnoremap <C-i> <C-i>

nnoremap <C-p> :<C-p>
nnoremap <C-q> <C-w>q

inoremap <C-l> <C-g>u<Esc>$[s1z=`]i<C-g>u
nnoremap <C-l> i<C-g>u<Esc>$[s1z=`]a<C-g>u<Esc>

nnoremap <C-s> :wa<cr>
inoremap <C-s> <Esc>:wa<cr>a

vnoremap < <gv
vnoremap > >gv

"tnoremap <A-h> <C-\><C-N><C-w>h|tnoremap <A-j> <C-\><C-N><C-w>j|tnoremap <A-k> <C-\><C-N><C-w>k|tnoremap <A-l> <C-\><C-N><C-w>l
"inoremap <A-h> <C-\><C-N><C-w>h|inoremap <A-j> <C-\><C-N><C-w>j|inoremap <A-k> <C-\><C-N><C-w>k|inoremap <A-l> <C-\><C-N><C-w>l

nnoremap H <C-w>h
nnoremap J <C-w>j
nnoremap K <C-w>k
nnoremap L <C-w>l

nmap <C-k> <Plug>NERDCommenterToggle
xmap <C-k> <Plug>NERDCommenterToggle

nnoremap \\ za
nmap \f <Plug>(easymotion-overwin-f)
xmap \f <Plug>(easymotion-overwin-f)
nmap \j <Plug>(easymotion-jumptoanywhere)
xmap \j <Plug>(easymotion-jumptoanywhere)
nmap \w <Plug>(easymotion-overwin-w)
xmap \w <Plug>(easymotion-overwin-w)
nmap \e <Plug>(easymotion-overwin-e)
xmap \e <Plug>(easymotion-overwin-e)
"nnoremap mf :wa<cr>:!make flash<cr>
"nnoremap mm :!make monitor<cr>

" grep or ack {{{1

" grep the words in the path where the file is located.
set opfunc=MyGrepFunc
func! MyGrepFunc(type)
  let s:store_temp_register=@z
  if a:type ==# 'v' || a:type ==# 'V' || a:type ==# ''
    normal! `<v`>"zy
  elseif a:type ==# 'char'
    normal! `[v`]"zy
  else
    return
  endif

  if LINUX()
    execute "Ack! " . expand(@z)
  elseif WINDOWS()
    silent! execute "vimgrep /" . expand(@z) . "/gj **/*.*"
  endif

  botright copen
  let @z=s:store_temp_register
endfunc
" }}}
" ManageMyVimrcFiles() {{{
func! ManageMyVimrcFiles()
  tabedit ~/.vim/.vimrc

  vsplit ~/.vim/.vimrc.mapping | vertical resize 1
  redraw
  call animate#window_percent_width(0.4)

  func! Fun1(id)
    wincmd h | split ~/.vim/.vimrc.bundle | resize 1
    redraw
    call animate#window_percent_height(0.5)
  endfunc

  func! Fun2(id)
    wincmd l | split ~/.vim/.vimrc.appearance | resize 1
    redraw
    call animate#window_percent_height(0.5)
  endfunc

  let tick = float2nr(g:animate#duration)
  call timer_start(tick*1, function("Fun1"))
  call timer_start(tick*2, function("Fun2"))
endfunc
" }}}
" Toggle background {{{
function! ToggleBG()
  let s:tbg = &background
  " Inversion
  if s:tbg == "dark"
    set background=light
    echo "set background=light"
  else
    set background=dark
    echo "set background=dark"
  endif
endfunction
" }}}
" QuickfixToggle() {{{
au FileType qf map <silent> <buffer> q <C-W>q|
      \  map <buffer> t <C-W><CR><C-W>T|
      \  map <buffer> gt <C-W><CR><C-W>TgT<C-W>j|
      \  map <buffer> o <CR>|
      \  map <buffer> go <CR><C-W>j|
      \  map <buffer> s <C-W><CR><C-W>K|
      \  map <buffer> gs <C-W><CR><C-W>K<C-W>b|
      \  map <buffer> v <C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t|
      \  map <buffer> gv <C-W><CR><C-W>H<C-W>b<C-W>J

func! QuickfixToggle(flag)
  if a:flag != "qf" && a:flag != "ll"
    echom "QuickfixToggle(flag): a:flag not valid!"
    return
  endif

  let qf_or_loc_list_is_open = a:flag == "qf" ? getqflist({'winid' : 0}).winid :
        \ getloclist(winnr(), {'winid' : 0}).winid
  if qf_or_loc_list_is_open
    if a:flag == "qf"
      cclose
    elseif a:flag == "ll"
      lclose
    endif
    wincmd p
  else
    if a:flag == "qf"
      botright copen
    elseif a:flag == "ll"
      lopen
    endif
  endif
endfunc
"}}}

" M (man): get helped {{{
nnoremap M K
vnoremap M K
au BufEnter *.rkt,*.rktl nnoremap <buffer> M :silent !raco docs <cword><cr>:redraw!<cr>
au BufEnter *.rkt,*.rktl vnoremap <buffer> M :call <SID>Racket_visual_doc()<cr>

" For the visual mode M mapping, it's slightly more convoluted to get the
" selected text:
function! s:Racket_visual_doc()
  try
    let l:old_a = @a
    normal! gv"ay
    call system("rack docs '". @a . "'")
    redraw!
    return @a
  finally
    let @a = l:old_a
  endtry
endfunction
" }}}
" {{{ Debug
" run <url:vimscript:packadd termdebug> to add Termdebug

nnoremap <F5>    :Run<cr>
nnoremap <S-F5>  :Continue
" set breakpoint
nnoremap <F9>    :Break<cr>
" step over
nnoremap <F10>   :Over<cr>
" step into
nnoremap <F11>   :Step<cr>
" step out
"nnoremap <S-F11> :Finish<cr>

"au BufEnter *.rkt,*.rktl nnoremap <buffer> <F5> :!racket -t %<cr>
"function! s:start_debug(ft)
"if ft == 'haskell'
"endif
"endfunction
" }}}
